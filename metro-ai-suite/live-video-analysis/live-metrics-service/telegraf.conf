# Configuration for telegraf agent
# Customized for Metrics Service - Standalone deployment
[agent]
  ## Default data collection interval for all inputs
  interval = "1s"
  ## Rounds collection interval to 'interval'
  round_interval = true
  ## Telegraf will send metrics to outputs in batches
  metric_batch_size = 2000
  ## Maximum number of unwritten metrics per output
  metric_buffer_limit = 20000
  ## Collection jitter
  collection_jitter = "0s"
  ## Default flushing interval for all outputs
  flush_interval = "1s"
  ## Jitter the flush interval
  flush_jitter = "0s"
  ## Precision for timestamps
  precision = "0s"

# Read metrics about cpu usage
[[inputs.cpu]]
  ## Whether to report per-cpu stats or not
  percpu = false
  ## Whether to report total system cpu stats or not
  totalcpu = true
  ## If true, collect raw CPU time metrics
  collect_cpu_time = false
  ## If true, compute and report the sum of all non-idle CPU states
  report_active = false
  ## If true and the info is available then add core_id and physical_id tags
  core_tags = false

# Read metrics about memory usage
[[inputs.mem]]

# Read CPU frequency from shell script
[[inputs.exec]]
  ## Commands array
  commands = ["/app/read_cpu_freq.sh"]
  ## Environment variables
  environment = []
  ## measurement name suffix
  name_suffix = ""
  ## Timeout for each command to complete
  timeout = "5s"
  ## Data format to consume
  data_format = "influx"
  ## Overrides the interval setting
  interval = "1s"

# Run executable as long-running input plugin (qmassa GPU monitoring)
[[inputs.execd]]
  ## One program to run as daemon
  command = ["python3", "/app/qmassa_reader.py"]
  ## Data format to consume
  data_format = "influx"

# Read metrics about temperature
[[inputs.temp]]
  ## Default config; collects all temps

# Process metrics using a Starlark script
[[processors.starlark]]
  ## Only metrics whose measurement name matches a pattern in this list
  namepass = ["temp"]
  ## Source of the Starlark script
  source = '''
def apply(metric):
    return metric if metric.tags.get("sensor", "").startswith("coretemp_package_id_") else None
'''

# Parse FPS metrics file if available
[[inputs.file]]
  ## Files to parse each interval
  files = ["/app/.collector-signals/fps.txt"]
  ## Data format to consume
  data_format = "value"
  data_type = "float"
  name_override = "fps"

# Configuration for the Prometheus client to spawn
[[outputs.prometheus_client]]
  ## Address to listen on
  listen = ":9273"
  ## Metric version controls the mapping
  metric_version = 1
  ## Path to publish the metrics on
  path = "/metrics"
  ## Collectors to enable
  collectors_exclude = ["gocollector", "process"]
  ## Send string metrics as Prometheus labels
  string_as_label = true
  ## Export metric collection time
  export_timestamp = true

# A plugin that can transmit metrics over WebSocket
[[outputs.websocket]]
  ## URL is the address to send metrics to
  url = "${WEBSOCKET_URL}"
  ## Data format to output
  data_format = "json"
  ## Set to 0s to avoid disconnections
  read_timeout = "0s"
